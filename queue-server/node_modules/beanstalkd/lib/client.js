'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _beanstalkdProtocol = require('beanstalkd-protocol');

var _beanstalkdProtocol2 = _interopRequireDefault(_beanstalkdProtocol);

var _readQueue = require('./read-queue');

var _readQueue2 = _interopRequireDefault(_readQueue);

var _reader = require('./reader');

var _writer = require('./writer');

var _commands = require('./commands');

var _lodash = require('lodash.camelcase');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

const debug = require('debug')('beanstalkd');
const debugError = require('debug')('beanstalkd:error');
const DEFAULT_HOST = '127.0.0.1';
const DEFAULT_PORT = 11300;

class BeanstalkdClient {
  constructor(host, port, options) {
    this.host = host || DEFAULT_HOST;
    this.port = port || DEFAULT_PORT;
    this.options = options || {};
    this.readQueue = null;
    this.writeQueue = _bluebird2.default.resolve();
    this.closed = false;
  }

  static addCommand(command, expected) {
    BeanstalkdClient.prototype[(0, _lodash2.default)(command)] = makeCommand(command, new _writer.BasicWriter(command), new _reader.BasicReader(expected));
  }

  static addYamlCommand(command, expected) {
    BeanstalkdClient.prototype[(0, _lodash2.default)(command)] = makeCommand(command, new _writer.BasicWriter(command), new _reader.YamlReader(expected));
  }

  destroy() {
    return this['delete'].apply(this, arguments);
  }

  connect() {
    return new _bluebird2.default((resolve, reject) => {
      debug('connecting to %s:%s', this.host, this.port);
      let connection = _net2.default.createConnection(this.port, this.host);

      connection.on('error', err => {
        this.closed = true;
        this.error = err;
        reject(err);
      });

      connection.on('connect', () => {
        debug('connected to %s:%s', this.host, this.port);
        this.connection = connection;
        this.closed = false;
        this.readQueue = new _readQueue2.default(this.connection);
        resolve(this);
      });

      connection.on('end', () => {
        debug('connection finished');
        this.closed = true;
      });

      connection.on('close', () => {
        debug('connection closed');
        this.closed = true;
        this.connection = null;
      });
    });
  }

  _command(command, args, writer, reader) {
    var _this = this;

    return (0, _bluebird.coroutine)(function* () {
      let connection = _this.connection,
          protocol = _this.protocol,
          spec = protocol.commandMap[command],
          result;

      if (spec.args.indexOf('bytes') > -1) {
        let data = args.pop();

        let b = new Buffer(data);
        args.push(b.length);
        args.push(data);
      }

      if (_this.closed) throw new Error('Connection is closed');

      let defered = defer();
      let onConnectionEnded = function onConnectionEnded(error) {
        defered.reject(error || new Error('CONNECTION_CLOSED'));
      };

      try {
        result = _this.writeQueue.then(function () {
          connection.once('close', onConnectionEnded);
          connection.once('error', onConnectionEnded);

          _this.readQueue.push(function (data) {
            return reader.handle(protocol, data, function (result) {
              connection.removeListener('close', onConnectionEnded);
              connection.removeListener('error', onConnectionEnded);

              defered.resolve(result);
            }, function (err) {
              connection.removeListener('close', onConnectionEnded);
              connection.removeListener('error', onConnectionEnded);

              defered.reject(err);
            });
          });
          writer.handle.apply(writer, [protocol, connection].concat(_toConsumableArray(args))).catch(defered.reject);

          return defered.promise;
        });

        _this.writeQueue = defered.promise.reflect();

        yield result;

        debug(`Sent command "${writer.command} ${args.join(' ')}"`);
      } catch (err) {
        debugError(`Command "${writer.command} ${args.join(' ')}" ${err.toString()}`);
        throw err;
      } finally {
        connection.removeListener('close', onConnectionEnded);
        connection.removeListener('error', onConnectionEnded);
      }

      return result;
    })();
  }

  unref() {
    this.connection.unref();
  }

  on(event) {
    var _connection;

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_connection = this.connection).on.apply(_connection, [event].concat(args));
  }

  quit() {
    this.closed = true;
    if (this.connection) {
      this.connection.end();
    }
    return _bluebird2.default.resolve();
  }
}

exports.default = BeanstalkdClient;
BeanstalkdClient.prototype.protocol = new _beanstalkdProtocol2.default();

_commands.commands.forEach((_ref) => {
  var _ref2 = _slicedToArray(_ref, 2);

  let command = _ref2[0],
      expectation = _ref2[1];
  return BeanstalkdClient.addCommand(command, expectation);
});
_commands.yamlCommands.forEach((_ref3) => {
  var _ref4 = _slicedToArray(_ref3, 2);

  let command = _ref4[0],
      expectation = _ref4[1];
  return BeanstalkdClient.addYamlCommand(command, expectation);
});

function makeCommand(command, writer, reader) {
  let handler = function handler() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return this._command(command, args, writer, reader);
  };

  return handler;
}

function defer() {
  let resolve, reject;
  let promise = new _bluebird2.default(function () {
    resolve = arguments[0];
    reject = arguments[1];
  });
  return {
    resolve: resolve,
    reject: reject,
    promise: promise
  };
}